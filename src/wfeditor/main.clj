(ns wfeditor.main
  ;; tells Clojure to generate a Java class out of this namespace --
  ;; this allows a standalone uberjar to be run by Java
  (:gen-class)
  (:require clojure.tools.cli)
  (:require [wfeditor.ui.gui.core :as gui]
            [wfeditor.model.workflow :as wflow]
            [wfeditor.io.relay.server :as server]
            [wfeditor.ui.util.swt-dispose :as swt-dispose]
            [wfeditor.io.util.const :as io-const]
            clj-ssh.ssh)
  (:import
   org.eclipse.swt.widgets.Display
   [com.jcraft.jsch JSch Logger]
   clj_ssh.ssh.SshLogger))

;; note: if underscore exists in a Java class path (e.g., one generated by
;; a Clojure deftype / defrecord with a dash in the Clojure path), the
;; Clojure path maintains a dash in require/ush while the import
;; statement for the Java class retains the underscore. see
;; clj_ssh.ssh.SshLogger from clj-ssh.ssh
;; note: clj-ssh.ssh.SshLogger is a deftype, so a require stmnt on the
;; containing ns and an import on the Java class of the type required,
;; like wfeditor.model.workflow.Job in providers.clj


;;
;; functions
;;

(defn handle-common-args
  "handle arguments and options that are common for the entire program, whether the program is eventually run in command-line mode, gui mode, or etc."
  [options args]
  ;; globally set the SSH logging level to ERROR (default is DEBUG)
  (JSch/setLogger (clj_ssh.ssh.SshLogger. com.jcraft.jsch.Logger/ERROR)))

(defn ui-create
  "The entry point to building the entire UI.  Uses a JFace idiom to do this, so UI code comes from an extended (proxied) ApplicationWindow.
TODO: handle options and args coming in from the CLI"
  [options args]
  (dosync (ref-set io-const/relay-type :client))
  (gui/initialize-gui)

  ;; The JFace idiomatic way of displaying a window.  As it seems, using
  ;; the "plain SWT" idiom for displaying a window doesn't work for
  ;; situations like a simple Label attached to the Shell, in the
  ;; following way: no Label widgets are painted on the Shell until the
  ;; user resizes the Shell.  The JFace style of doing things works
  ;; properly as expected.
  ;; If there is any code that should've gone in what would've been a
  ;; subclass constructor, that should go somewhere here, where the
  ;; instance is actually being returned and manipulated
  (let [app-win (wfeditor.ui.gui.core/app-win-proxy)]
    ;; must create the menu bar before the Shell is constructed i.e.,
    ;; the addMenuBar call should go in the constructor, but
    ;; constructor code goes here instead
    (.addMenuBar app-win)

    ;; TODO: use CLI options and args to modify the UI here, which is
    ;; after its instantiation 
    (. app-win setBlockOnOpen true)
    (. app-win open)
    (swt-dispose/dispose-all)
    (when-let [display (. Display getCurrent)]
      (.dispose display)))

  (gui/cleanup-gui)
  ;; still have a problem with getting the program to fully shutdown
  ;; at least on Mac OS X.
  ;; this is caused somehow by the GMF graphics object used to export
  ;; the canvas to SVG (even though the object seems to get disposed
  ;; by the macro code). it causes Mac Java system to spawn an AWT
  ;; thread, but the Mac Java system doesn't support the dual AWT &
  ;; SWT system that SWT uses.  putting in a System.exit call to make
  ;; sure that the program exits until this issue gets (understood
  ;; and) resolved.
  ;; System/exit resolution from
  ;; http://www.eclipse.org/forums/index.php/m/652136/
  ;; info on CocoaComponent compatibility mode:
  ;; https://developer.apple.com/library/mac/documentation/Java/Reference/1.5.0/appledoc/api/com/apple/eawt/CocoaComponent.html
  ;; For a possible fix, might try invokeLater as described by
  ;; http://www.eclipse.org/swt/faq.php#swtawtosx
  ;; and https://bugs.eclipse.org/bugs/show_bug.cgi?id=67384
  (System/exit 0)
  )

(defn cli-execute
  "The entry point for executing the CLI version of the program"
  [options args]
  (dosync (ref-set io-const/relay-type :client))
  ;; TODO: create functionality of program!
  )

(defn server-execute
  "The entry point for creating the server version of the program"
  [options args]
  (dosync (ref-set io-const/relay-type :server))
  (server/initialize-server-process)
  (let [port (:port options)
        new-server (server/new-running-server {:port port})]
    (server/set-server new-server)))

(defn parse-args
  "parse the command-line arguments and, as the clojure.tools.cli provides, returns a vector containing 3 elements: 1) the parsed options, 2) remaining arguments, and 3) a help banner. works well with user-args as a list of the command-line arguments"
  [user-args]
  (let [[options arguments banner] (clojure.tools.cli/cli user-args
                                        ["-g" "--[no-]gui" "Run the GUI frontend with the program" :default true :flag true]
                                        ["-h" "--help" "Display the command-line help statement" :default false :flag true]
                                        ["-p" "--port" "(server mode) the port of the server process" :default io-const/DEFAULT-PORT :parse-fn #(Integer/parseInt %) ]
                                        ["-S"  "--server" "Run in server mode" :default false :flag true])]
    (when (:help options)
      (println banner)
      (System/exit 0))
    [options arguments banner]))

(defn -main
  "main method (i.e., entry point) for the entire WFE"
  [ & args]
  (let [[options parsed-args banner] (parse-args args)]
    (handle-common-args options args)
    (cond
     (true? (:server options)) (server-execute options parse-args)
     (false? (:gui options))  (cli-execute options parsed-args)
     :else (ui-create options parsed-args))))
