(ns wfeditor.main
  ;; putting the import statement in the ns form is the preferred way
  ;; of importing Java classes in Clojure (see http://pragprog.com/magazines/2010-11/getting-clojure)
  (:import
  org.eclipse.jface.window.ApplicationWindow
  org.eclipse.swt.SWT
  org.eclipse.swt.layout.FillLayout
  (org.eclipse.swt.widgets Display Shell Label)))


;; JFace way of creating a window is to subclss ApplicationWindow and
;; override createContents
;; This is the Clojure way of "subclassing", i.e., extending a class
;; via the proxy macro.  This function just returns the instance of
;; the anonymous class generated by proxy
(defn proxy-handler []
  (proxy [ApplicationWindow]
      [nil]  ;; calling the ApplicationWindow constructor
    ;; note, should not implement any subclass constructor, as
    ;; explained in
    ;; http://pragprog.com/magazines/2010-11/getting-clojure
    ;; Instead, any code that would go in the subclass construtor
    ;; should be applied to the instance of the extended class
    ;; returned by proxy
    (createContents [parent]
      (let [label2 (Label. parent  SWT/CENTER)]
        (doto label2
          (.setText "Hello, World"))))))

;; The JFace idiomatic way of displaying a window.  As it seems, using
;; the "plain SWT" idiom for displaying a window doesn't work for
;; situations like a simple Label attached to the Shell, in the
;; following way: no Label widgets are painted on the Shell until the
;; user resizes the Shell.  The JFace style of doing things works
;; properly as expected.
;; If there is any code that should've gone in what would've been a
;; subclass constructor, that should go somewhere here, where the
;; instance is actually being returned and manipulated
(let [app-win (proxy-handler)]
  (. app-win setBlockOnOpen true)
  (. app-win open)
  (.dispose (. Display getCurrent))
  )
